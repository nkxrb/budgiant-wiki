为了更好的高效、规范、优雅的书写代码，同时配合代码生成原则，我们需要约定一些建表规范，这些规范并不具备强制性，仅仅是为了方便自动生成的代码能稳定运行。

1.	表注释 	------映射-----> 实体类描述
2.	表字段 	------映射-----> 实体类属性
3.	字段类型	------映射-----> 属性数据类型
4.	字段注释	------映射-----> 属性说明
5.	字段长度	------映射-----> 属性值长度校验限制

6.	表必须要有主键。目前生成代码的功能仅支持单个主键情况，尽量设计为单主键表。

7.	主键尽可能加以区分，最好使用：类名_id 这种命名方式，可使逻辑更为清晰。其他属性也可使用这种方式：类名_属性名。

8.	一些通用属性，命名可以保持统一，不用区分，如：approveStatus（审核状态），每个表中总是加上 del_flag（删除标识）、sys_created（创建时间）、sys_modified（最后一次更新时间） 这三个字段。

9.	加入del_flag，是为了实现数据库数据的完整性，所有用户操作均限制为软删除，当垃圾数据过多时将启用定时器等等进行统一处理，降低误删的可能

10.	大多主键采用自增形式的可以提高性能，且非庞大的单一部署系统，自增主键完全可以满足要求，但也有些数据主键不推荐采用主键自增，比如：用户id...比较私密的数据，使用主键自增很容易猜测下一个id，可实现有
	规律的递推，此时可考虑SnowFlake雪花算法生成主键，毫秒级时间+机器码+标识+随机数，有序long型数据可提高查询性能（注意时钟回退问题的解决），UUID无序，长度长，唯一性强，但对数据的存储读写不太友好，碎片化严重，因此尽可能不考虑UUID作为主键。

11.	MySQL中，日期格式的字段使用datetime类型存储（注意时区问题）。sys_modified可使用timestamp,实现实时更新

12.	禁止使用复杂数据类型（数组，自定义类型等）。数据类型尽量简洁，严谨，长度不要过长

13.	在创建表的附属表时，附属表id与主表id保持一致。不允许在附属表新增主键字段。

14.	在设计表时，若遇到可扩展类型的属性时，请设计成纵表，使逻辑更为清晰。

15.	存在过期概念的表，在其设计之初就必须有过期机制，且有明确的过期时间。过期数据必须迁移至历史表中。

16.	不再使用的表，必须通知DBA予以更名归档。

17.	线上表中若有不再使用的字段，为保证数据完整，禁止删除。或者将数据备份留存，批处理到新表中等。

18.	不要使用外键来强制数据关系绑定，提高数据库性能，也为后期数据表重构带来可能。

19.	在设计冗余字段时，请考虑数据的时效性，如果是历史性数据，需要将对象信息进行定格存储，若是关联性查询实时性高，变动频繁的，请不要在多个表中设置冗余字段，以免造成数据不一致现象。

20.	系统字典表是必要的。请在遇到枚举型数据时，使用value--label进行映射。类型计数最好从1开始，mybatis对0的处理不算友好。注意归类设计，尽可能保证相同类型的状态数据一致。
	比如不同对象的审核状态，可使用同一套字典

21.	请合理使用sys_operator_log（系统操作日志表），记录数据库的每次改动。

22.	索引是需要考虑的。在存在关联关系的表之间，给关联字段加索引可提高查询性能，再多个索引出现时，请考虑下组合索引的可能，尽量缩短索引长度，提高数据的写入性能。

23.	唯一索引请不要滥用。唯一索引可以限制数据的唯一性，但请尽量在代码中处理这种限制，减少数据库的执行操作。

24.	当遇到计算复杂的逻辑时，可考虑将计算结果一起存储，避免重新计算。

25.	尽可能的把字段定义为NotNULL，mysql比较难优化使用了可空列的查询，它会使索引，索引统计更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理，当可空列被索引时，每条记录都需要一个额外的字
	节。 即使要在表中存储"没有值"的字段，考虑使用0，特殊字段或者空字符串来代替。

26.	禁止使用key、value、desc、group、select... 等SQL关键词作为表字段，这样会给SQL语句的编译带来麻烦。

99.	禁止使用OCI驱动，全部使用THIN驱动。（网上看到的，不懂，需要研究一下）。